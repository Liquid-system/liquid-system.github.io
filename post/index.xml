<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 時祷書</title><link>https://liquid-system.github.io/post/</link><description>Recent content in Posts on 時祷書</description><generator>Hugo -- gohugo.io</generator><language>ja-JP</language><lastBuildDate>Sat, 25 Mar 2023 05:34:11 +0900</lastBuildDate><atom:link href="https://liquid-system.github.io/post/index.xml" rel="self" type="application/rss+xml"/><item><title>Typst</title><link>https://liquid-system.github.io/post/typst/</link><pubDate>Sat, 25 Mar 2023 05:34:11 +0900</pubDate><guid>https://liquid-system.github.io/post/typst/</guid><description/></item><item><title>ChatGPTにneovimプラグインの作り方を教えてもらった</title><link>https://liquid-system.github.io/post/chatgpt%E3%81%ABneovim%E3%83%97%E3%83%A9%E3%82%B0%E3%82%A4%E3%83%B3%E3%81%AE%E4%BD%9C%E3%82%8A%E6%96%B9%E3%82%92%E6%95%99%E3%81%88%E3%81%A6%E3%82%82%E3%82%89%E3%81%A3%E3%81%9F/</link><pubDate>Mon, 20 Mar 2023 05:23:18 +0900</pubDate><guid>https://liquid-system.github.io/post/chatgpt%E3%81%ABneovim%E3%83%97%E3%83%A9%E3%82%B0%E3%82%A4%E3%83%B3%E3%81%AE%E4%BD%9C%E3%82%8A%E6%96%B9%E3%82%92%E6%95%99%E3%81%88%E3%81%A6%E3%82%82%E3%82%89%E3%81%A3%E3%81%9F/</guid><description>ChatGPTシリーズ第二弾
いい加減neovimのプラグインを作りたい！という事でChatGPTさんに相談してみた
本題 「neovimのプラグインを作りたい」 返答
Neovimのプラグインを作成するには、以下の手順を実行する必要があります。
1.NeovimのAPIを理解する Neovimは、Lua、Python、VimScriptなどの言語で拡張できます。プラグインを作成する前に、NeovimのAPIを理解する必要があります。これには、Neovimのドキュメントを参照することが含まれます。特に、APIドキュメントはプラグインを作成するために必要な情報を提供します。 2.プラグインのアイデアを決める 次に、作成するプラグインのアイデアを決定します。Neovimは非常に柔軟なエディタであるため、様々な種類のプラグインを作成できます。例えば、新しい機能を追加したり、既存の機能を拡張したり、外部サービスとの連携を行うためのプラグインを作成することができます。 3.プラグインの実装 プラグインの実装には、プラグインをどの言語で書くかによって異なります。VimScriptで書く場合は、.vimファイルに書き、LuaまたはPythonで書く場合は、LuaまたはPythonのファイルに書く必要があります。プラグインを書くときに、必要に応じてNeovimのAPIを使用して機能を追加することができます。 4.テストとデバッグ プラグインが正常に動作するようになったら、テストを実行し、問題があれば修正します。テストには、手動テストと自動テストの両方が含まれます。手動テストでは、プラグインを使用して実際に動作を確認することができます。自動テストでは、テストスクリプトを作成して、プラグインの機能が正常に動作することを確認することができます。 5.ドキュメントとリリース 最後に、プラグインのドキュメントを作成し、リリースします。ドキュメントには、プラグインの使用方法や機能についての説明が含まれます。リリースは、プラグインのバージョン管理やパッケージングなどを行う必要があります。
以上が、Neovimのプラグインを作成するために必要な手順です。
質問：「neovimのプラグインをluaで書きたい、neovimのAPIにはどんなものがある？」 chatGPTの返答
Neovimは、Lua言語をサポートしており、Neovim APIを使用してLuaでNeovimプラグインを作成することができます。Neovim APIには、以下のような機能が含まれています。 1.ウィンドウとバッファの制御 ウィンドウやバッファを作成、削除、変更、移動、スクロールなどを行うための関数が提供されています。 2.テキスト編集の制御 テキストを追加、削除、変更、カーソル位置の変更、ファイル読み書きなどを行うための関数が提供されています。 3.カーソル移動の制御 カーソルを移動、ジャンプ、検索、置換、マークなどを行うための関数が提供されています。 4.ハイライト、スタイルの設定 テキストやUI要素の色やスタイルなどの設定を行うための関数が提供されています。 5.UI制御 ウィンドウやタブのサイズ変更、カーソル位置の表示、ステータスバーの表示、キーバインドの設定などを行うための関数が提供されています。 6.イベント処理 イベントの発行、受信、処理などを行うための関数が提供されています。 これらの機能に加えて、Neovim APIは、エラーハンドリング、非同期処理、プラグイン設定の読み書きなどの機能を提供しています。これらの機能は、LuaプログラマーがNeovimプラグインを制御するために必要な機能を提供しています。
質問：「apiはどのように選べばよいのでしょうか？」 返答
NeovimのAPIは非常に多岐にわたり、初めてNeovimプラグインを作成する場合は、APIの選択が重要な役割を果たします。APIの選択には、以下のような点を考慮することが重要です。 機能の必要性 最初に、自分のプラグインが必要とする機能が何であるかを決定する必要があります。例えば、テキストの編集やウィンドウの制御が必要であれば、nvim_buf_, nvim_win_のAPIを使用する必要があります。 パフォーマンス APIのパフォーマンスは、プラグインの動作に大きな影響を与えることがあります。例えば、プラグインが高速なテキスト処理を必要とする場合は、APIのパフォーマンスが高いnvim_buf_* APIを使用することをお勧めします。 APIの安定性 APIの安定性は、将来のバージョンアップでの互換性を保つために重要です。例えば、vim.api.nvim_*のAPIは、Neovimの安定バージョンであるv0.5以降で使用可能であり、将来のバージョンでも互換性が保たれると予想されます。 ドキュメンテーションの質 APIの質の高さは、APIのドキュメンテーションが充実しているかどうかによって決まります。ドキュメンテーションが充実しているAPIは、プラグイン開発者がAPIを理解しやすく、開発を効率的に進めることができます。 以上のような点を考慮して、APIを選択することが重要です。初めてのNeovimプラグイン開発の場合は、公式のドキュメントを参照することをお勧めします。
質問：「おすすめの学習方法は？」 解答
Neovimのプラグイン開発を学ぶためには、以下のような学習方法がおすすめです。
公式ドキュメントの読み込み まずは、公式ドキュメントを読んでAPIの基本的な使用方法や構文を学びます。公式ドキュメントには、APIリファレンスやチュートリアル、FAQなどが含まれています。 1.サンプルプラグインの作成 次に、サンプルプラグインを作成してAPIを実際に使用してみましょう。公式ドキュメントには、サンプルプラグインのコード例も含まれています。また、GitHubなどのオープンソースプロジェクトから、実際に使用されているプラグインのコード例を見つけることもできます。 2.オンラインコミュニティの参加 Neovimのオンラインコミュニティに参加して、他の開発者と交流しましょう。オンラインコミュニティでは、質問や問題解決に役立つ情報や、新しいAPIやプラグインのアイデアが共有されています。 3.書籍やチュートリアルの参照 Neovimプラグイン開発に関する書籍やチュートリアルも存在します。これらの資料は、より詳細な解説や実践的なアドバイスを提供してくれます。 4.実践的なプロジェクトに取り組む 最後に、実践的なプロジェクトに取り組んでみましょう。自分が開発したいプラグインや、既存のプラグインの改善など、具体的なプロジェクトを設定して開発に取り組むことで、より実践的なスキルを身につけることができます。 以上の学習方法を組み合わせることで、Neovimのプラグイン開発に必要な知識やスキルを身につけることができます。ただし、学習のペースは人それぞれ異なるため、自分に合った学習方法を見つけることが重要です。
もうこれほとんどChatGPTの引用で技術記事が成り立ってしまうじゃないか(困惑) でもこのおかげで質問に答える手間が軽減されて良いのかも？ ちなみに、誤った情報を指摘すると訂正してくれる。ChatGPTの衝撃が今更ながら身をもって体験しました。</description></item><item><title>ChatGPTに範囲for文を説明してもらった</title><link>https://liquid-system.github.io/post/%E7%AF%84%E5%9B%B2for%E6%96%87/</link><pubDate>Mon, 20 Mar 2023 04:12:33 +0900</pubDate><guid>https://liquid-system.github.io/post/%E7%AF%84%E5%9B%B2for%E6%96%87/</guid><description>C++で範囲for文の例を見ていると&amp;amp;がついていたりいなかったり、二つ付いている場合がある。その違いが判らなかったので流行りのchatGPTに聞いてみた。
そもそも範囲for文ってなによ まず初めに「c++での範囲for文を教えてください」と聞いてみた。 以下、chatGTPの返答
C++での範囲for文は、配列やコンテナの要素を順番に取り出して処理するための構文です。以下は、範囲for文の基本的な書き方です。
for (データ型 要素名 : 配列またはコンテナ名) { // 要素に対する処理を記述する } 例えば、int型の配列を対象に範囲for文を使って要素を表示する場合、以下のように書くことができます。
#include &amp;lt;iostream&amp;gt; using namespace std; int main() { int arr[] = {1, 2, 3, 4, 5}; // 範囲for文で配列の要素を表示する for (int x : arr) { cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#34; &amp;#34;; } cout &amp;lt;&amp;lt; endl; return 0; } 上記のプログラムは、配列arrの要素を順番に取り出して、変数xに代入しています。そして、xの値を表示することで、配列の要素を順番に表示しています。
念のためサンプルコードを試してみると無事コンパイルでき、1 2 3 4 5と出力される。
本題 当初の疑問であった範囲for文の参照云々について聞いてみる。 「範囲for文の要素名に&amp;amp;が付く場合があります。それはなぜですか？」 返答
範囲for文の要素名に&amp;amp;が付く場合、参照渡しを行うことを意味します。参照渡しは、関数に引数を渡す方法の一つで、引数のコピーを作らずに元の変数を直接操作できるようになります。同様に、範囲for文でも、要素をコピーするのではなく、元の配列やコンテナの要素を直接操作することができます。
以下は、範囲for文で参照渡しを使用した例です。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; using namespace std; int main() { vector&amp;lt;int&amp;gt; vec = {1, 2, 3, 4, 5}; // 範囲for文でコンテナの要素を2倍にする for (int&amp;amp; x : vec) { x *= 2; } // コンテナの要素を表示する for (int x : vec) { cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#34; &amp;#34;; } cout &amp;lt;&amp;lt; endl; return 0; } 上記のプログラムでは、vectorの要素を2倍にするために、範囲for文で参照渡しを使用しています。変数xが要素への参照となり、要素を直接操作することができます。そのため、範囲for文の後にvectorの要素を表示すると、すべての要素が2倍になっていることが確認できます。</description></item><item><title>Rustに入門したい(願望)</title><link>https://liquid-system.github.io/post/rust%E3%81%AB%E5%85%A5%E9%96%80%E3%81%97%E3%81%9F%E9%A1%98%E6%9C%9B/</link><pubDate>Sat, 18 Mar 2023 00:24:18 +0900</pubDate><guid>https://liquid-system.github.io/post/rust%E3%81%AB%E5%85%A5%E9%96%80%E3%81%97%E3%81%9F%E9%A1%98%E6%9C%9B/</guid><description>重い腰を上げてとうとうRustに入門した。 使った参考書はコンセプトから理解するRustを使用する。
最初のコードでは二つの整数を引数に取り、除算する関数を用意した。そしてその結果を標準出力へ出力＋ゼロによる除算をerrorとしている。
ここがわからん(と回答) サンプルコードの関数名の意図がよくわからんfunc_ex_div_someとあるけど説明の都合なのかな？ &amp;amp;'static strとある、'ってなによ マクロと関数の違い、あとC言語やgolangのpackage mainみたいなのがない Tってなに？(C++みたいなテンプレートの略なのか？) -&amp;gt; Optionとかの場合あらゆる型に対応している為に可変のパラメータになっている。 -&amp;gt; どんな方でもよいという訳ではなさそう、T: std::fmt::Displayみたいにメゾットが容易されている型に制限している(トレイト境界と呼ぶらしい) 引数の後ろにある型は「型アノテーションと呼ぶらしい」 Option型っていうのにも注意したい、Typescriptでいうオプションパラメーターっぽい
Rustでのモジュール クレート バイナリクレート(実行モジュール用) ライブラリクレート(ライブラリ用、cargo new --libsと打つと作れる) の二種類ある</description></item><item><title>lualine.nvimでステータスラインをカスタマイズしよう！</title><link>https://liquid-system.github.io/post/lualine.nvim%E3%81%A7%E3%82%B9%E3%83%86%E3%83%BC%E3%82%BF%E3%82%B9%E3%83%A9%E3%82%A4%E3%83%B3%E3%82%92%E3%82%AB%E3%82%B9%E3%82%BF%E3%83%9E%E3%82%A4%E3%82%BA%E3%81%97%E3%82%88%E3%81%86/</link><pubDate>Fri, 17 Mar 2023 22:33:33 +0900</pubDate><guid>https://liquid-system.github.io/post/lualine.nvim%E3%81%A7%E3%82%B9%E3%83%86%E3%83%BC%E3%82%BF%E3%82%B9%E3%83%A9%E3%82%A4%E3%83%B3%E3%82%92%E3%82%AB%E3%82%B9%E3%82%BF%E3%83%9E%E3%82%A4%E3%82%BA%E3%81%97%E3%82%88%E3%81%86/</guid><description>この記事はvim駅伝3/17日の記事です。
neovimやvimを豪華に彩る中でおそらく必須となるであろうステータスライン系プラグインの紹介記事です。
現在公開されているプラグインは様々な種類がありますが、luaで書かれた中ではおそらくlualine.nvimがデファクトです。
https://github.com/nvim-lualine/lualine.nvim
導入後 筆者のコード
https://github.com/Liquid-system/NeovimConfig/blob/main/lua/plugins/lualine.lua
READMEが非常に丁寧に書かれているので、ステータスラインの位置を指定し、lualineに同梱されているコンポーネントを設定するのが定石ですが、筆者はlualine.nvimのexamplesディレクトリにあるevil_lualine.luaをカスタマイズしています。
https://github.com/nvim-lualine/lualine.nvim/blob/master/examples/evil_lualine.lua
改良すべき点 Lspを表示するコンポーネントです。null-lsなどのフォーマット系プラグインを使用している場合はclient.name ~= &amp;quot;null-ls&amp;quot; thenとif文で除外するのがベターです。
ins_right { -- Lsp server name . function() local msg = &amp;#34;No Active&amp;#34; local buf_ft = vim.api.nvim_buf_get_option(0, &amp;#34;filetype&amp;#34;) local clients = vim.lsp.get_active_clients() if next(clients) == nil then return msg end for _, client in ipairs(clients) do local filetypes = client.config.filetypes if filetypes and vim.fn.index(filetypes, buf_ft) ~= -1 and client.name ~= &amp;#34;null-ls&amp;#34; then return client.name end end return msg end, icon = &amp;#34; LSP:&amp;#34;, color = { fg = colors.</description></item><item><title>遅ればせのCSS入門</title><link>https://liquid-system.github.io/post/%E9%81%85%E3%82%8C%E3%81%B0%E3%81%9B%E3%81%AEcss%E5%85%A5%E9%96%80/</link><pubDate>Thu, 09 Mar 2023 01:54:19 +0900</pubDate><guid>https://liquid-system.github.io/post/%E9%81%85%E3%82%8C%E3%81%B0%E3%81%9B%E3%81%AEcss%E5%85%A5%E9%96%80/</guid><description>今までだましだまし書いてきたCSSにも限界を見せてきたのでここいらで一つ、真面目にCSSに入門してみようと思う。
という訳で現場のプロから学ぶ CSSコーディングバイブルの学習メモを書いておく
CSSって? CSSとはカスケーディングスタイルシート(Cascading Style Sheet)の略。HTMLを装飾する役割を持つ。 CSS Working Groupのメンバーによって仕様が決められているらしい。
基本文法 HTMLにCSSを適応させるには3種類の方法を持つ。
HTMLのstyle属性に直接CSSを置く HTMLのstyleタグでCSSを挟む linkタグのhref属性にCSSファイルを読み込ませる　←主流 文法は単純(?)
.text { background :#ccc; } 用語の説明 .text: セレクタ、装飾を適応したい箇所を指す background:: プロパティ、MDNでは
CSS のプロパティは、関連付けられた値によりブラウザーがどのように要素を表示するかを定義する特性です。
1 とある。
#ccc;: 値、まあ説明は不要だろう
キー概念 CSSを考える上で4つの概念が重要とある。
カスケード 継承 優先度 詳細度 CSSで言うCascading、つまり上から下へ流れる滝のように、指定したセレクタが複数ある場合は下の行で上書きされる。 htmlタグの値は親から子へ受け継がれ、親要素で指定されている要素は継承プロパティと呼ばれる。そして、上書きされない限り子へ引き継がれる。 親子関係の例
&amp;lt;h2 class=&amp;#34;title&amp;#34;&amp;gt;見出し&amp;lt;span&amp;gt;サブタイトル&amp;lt;/span&amp;gt;&amp;lt;/h2&amp;gt; では
.title(親) &amp;gt; span(子) となる CSSを書く上で重要なのがCSS優先度。まあどの値を優先するかを決めると考えればよいだろう。 具体的な優先度はこんな感じ 優先度高 style属性 IDセレクタ クラスセレクタ、属性セレクタ、擬似クラスセレクタ 要素セレクタ、疑似要素セレクタ 優先度低 詳細度が高いほど優先される。
セレクタ IDセレクタ、クラスセレクタ、要素セレクタはよく見るね
CSS設計 この辺りを読みたかった。CSSのコーディングスタイルには3つ代表的なものが存在する。
OOCSS BEM SMACSS クラスにも代表的な指定方法が3つある。
マルチクラス、装飾や機能ごとにクラスを分ける (Boostrapで使われる)
ここがイイ！ 再利用性が高い ここがダメ！ styleの適応範囲が分かりにくい シングルクラス、使用する目的に合わせてクラスを作成</description></item><item><title>日付フォーマットの変更できるようにした。</title><link>https://liquid-system.github.io/post/%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/</link><pubDate>Tue, 28 Feb 2023 21:31:55 +0900</pubDate><guid>https://liquid-system.github.io/post/%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/</guid><description>hugoテンプレートのメモ このサイトはkissというテーマを使用している。日にちのフォーマットが気に入らないのでYYYY-MM-DDにしたかったのだが、そこそこ苦労したのでメモ
結論 こうした
&amp;lt;h2 class=&amp;#34;subtitle is-6&amp;#34;&amp;gt; {{- $.Site.Params.Info.dateFormat | default &amp;#34;January 2, 2006&amp;#34; | .Date.Format -}} &amp;lt;/h2&amp;gt; hugoではgolangのtext/templateを使って表示するひな形を設定している。(pythonで言うjinja2みたいなもの) その際に日付のフォーマットを設定するのだがJanuary 2, 2006と、どう見ても特定の日付にしか見えない形式にしなければならない。 kissではすでにひな形からフォーマット指定されてあったので元のhtmlごと変更しなければならなかった。 上記のコードではgoテンプレートで使われるパイプを使用し、変数$.Site.Params.Info.dateFormatをhugoの関数defaultに渡している</description></item><item><title>hugo導入メモ</title><link>https://liquid-system.github.io/post/hugo%E5%B0%8E%E5%85%A5%E3%83%A1%E3%83%A2/</link><pubDate>Mon, 27 Feb 2023 22:22:32 +0900</pubDate><guid>https://liquid-system.github.io/post/hugo%E5%B0%8E%E5%85%A5%E3%83%A1%E3%83%A2/</guid><description>このサイトはhugoと GitHub Pages を使って運用している。
詰まった点 workflows のパーミッション設定 gh-pages ブランチが作られるはずが write 権限がオフになっていた為アクセスできなかった。参考 Permission denied to github-actions[bot]. The requested URL returned error: 403 icon が変更できない。 プレビュー段階では初期アイコンのままらしい。デプロイしたら変更できた。</description></item><item><title>ブログを始めた</title><link>https://liquid-system.github.io/post/hello/</link><pubDate>Mon, 27 Feb 2023 18:22:07 +0900</pubDate><guid>https://liquid-system.github.io/post/hello/</guid><description>簡易なブログを作った。技術関係のメモとか書評aとかをこの辺で載せられたらいいな。</description></item></channel></rss>